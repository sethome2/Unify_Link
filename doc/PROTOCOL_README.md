每一帧的数据结构如下：
| 帧头 0xA0 | 序列号 uint8 | 组件ID uint8 | 数据ID uint8 | 数据载荷长度 uint16 | CRC-16校验码 uint16 | 数据载荷 uint8[数据长度] |（协议开销 8字节）

首先帧头固定为0xA0，每次解码时，先判断第一个数据是否为0xA0，如果不是，则顺延，直到找到0xA0为止，并且CRC-16校验码正确，则认为解码成功，
如果CRC-16校验码不正确，则认为解码失败，需要重新解码，回到帧头，继续解码，直到找到0xA0为止，并且CRC-16校验码正确，则认为解码成功。

解码成功后，根据组件ID和数据ID，判断是哪个组件的哪个数据，然后根据数据长度，读取数据载荷，并利用memcpy将数据载荷复制到对应的变量中。

解码成功的序列号应为上次的序列号+1，如果上次的序列号为255，则应为0。

解码的次数记录到一个结构体中，里面包含成功解码的次数，失败次数，以及不同组件ID和数据ID的解码次数。

编写以上符合要求的C代码，并给出测试代码，测试代码中，需要模拟数据传输，模拟数据传输的丢包率，模拟数据传输的误码率。
自定三个组件和虚拟的三个数据结构体，结构体数据长度分别为256字节，128字节，64字节，结构体成员为uint8_t类型，按0-255的顺序填充数据。

这个是一个通讯协议库，因此需要准备三个API，一个api为接受api，输入为uint8_t* 和接受数据长度，内部准备fifo缓存，fifo缓存大小为1024字节。

第二个api为发送api，输入为组件ID，数据ID，数据载荷指针，数据载荷长度，以及一个发送缓冲区指针，成功返回长度，失败返回-1。

第三个API为数据处理API，输入为组件ID，数据ID，数据载荷指针，数据载荷长度，内置switch case，根据组件ID和数据ID，调用不同的处理函数，处理函数为void类型，输入为数据载荷指针，数据载荷长度。




```
pip install build
python -m build
```



